SPRING BASICS - I



Famework - everything is predefined as modules

1. Security - Spring supports Security
2. JDBC - Spring JDBC supports the DB connectivity
3. Monitoring - We do have Actuator
4. AOP - Aspect Oriented Programming [ to address Cross Cutting Concerns]
5. MVC - Spring MVC module supports the Model View Controller Design pattern

Standalone Spring Programs : Spring Core



Spring Modules
Spring FW 


Loose Coupling is achieved -> See this step by step



Spring core concepts:

1. IoC Container - Inversion of Control

	- In Java creation of objects is done by Developer
	- We are delegating the responsibility of Object creation to Spring Container
	- config file : springbeans.xml
	- In the config file we declare all the beans
	- Every object created by spring is called -> Spring "BEAN"



2. Wrong Impression:

	- Spring IoC will created the beans declared in the the config (.xml) file
	- But still you can create the objects in normal way
	- "new A();"

3. Dependency Injection
	- The concept of injecting dependencies into respective beans/classes using Spring concepts	

	-Types of DI's

	- Constructor: DEPENDENCY INJECTION
	- Setter : DEPENDENCY INJECTION

4. How to configure a Spring Application:

	(a) XML Configuration (beans.xml)
	(b) Java Based Configuration 
		-> entire XML is replaced by a JAVA File
	(c) Annotations

5. Annotations:
	
	-(a) @Component	- Class level Annotation
	(b) @Controller - Class level Annotation
	(c) @Service	- Class level Annotation
	(d) @Repository	- Class level Annotation
	-(e) @Bean
	-(f) @ComponentScan
	-(g) @Autowired  - Tells the Container how to inject the dependencies
	-(h) @Configuration
	(i) @Qualifier


Steoreotype Annotations
	->  (a), (b), (c), (d), (h), @ControllerAdvice, @RestController



Client (Browser)  ->   Controller(Servlet) -> Service -> DAO    -> DB

Servlet/Controllers : receives the incoming request
Service : You perform the business logic



6. Bean Scopes
	- 1. Singleton
	- 2. Prototype
	- 3. request
	- 4. session
	- 5. Global Session(Deprecated - from Spring 5.x)
	- 5. Application


7. Bean Lifecycle 
	- init()
	- destroy()

	- 3 different ways to achieve overriding the lifecycle methods
		a. use xml attributes 
		b. annotations [@PostConstruct  ,  @PreDestroy]
		c. can implement 2 interfaces
			(i) InitializingBean
			(ii) DisposableBean

8. Autowiring
	- Process of connecting 2 Beans
	- Achieving Dependency Injection

	- XML         [autowire="byName"    autowire="byType"]
          Annotation  [Autowiring modes]

	- Autowiring modes -> byName, byType, no


9. Qualifier -> 
		



10. ClassPathXmlApplicationContext:

	i/p to the class 
		-> "spring-beans.xml"   [XML file]

	ctx (object)
		 -> provides API 
			-> to extract beans generated by container


	id in <bean id="<id of the bean>"> delcaration 
		-> must match the getBean("<id of the bean>") 

	Typecast the bean provided by the container (getbean())

	ctx.close()


11.AnnotationConfigApplicationContext:
	
	i/p to the class
		-> "SpringJavaConfig.class"   
		-> [class annotated with @ Configuration]

	ctx (object)
		 -> provides API 
			-> to extract beans generated by container

	methodname of method annotated with @Bean (in @Configuration file)
		-> must match the getBean("<method name>")


	Typecast the bean provided by the container (getbean())



	ctx.close()


12.  	@Bean(name="c") -> alias name of the object being returned
	@Bean(name="b") -> alias name of the object being returned


13. spring-beans.xml  =====   @Configuration (SprinJavaConfig.class)
    <bean> 	      =====   @Bean
    <bean id="">      =====   name of the method



14. @ComponentScan

	Def: Instead of explicitly specifying the Bean declarations 
			-> either in xml
			-> or in Configuration file

	     Use "ComponentScan"


	- In XML
		<context:component-scan basePackage="com.deloitte">
				</context: component-scan>


	- In Configuration Class
		@ComponentScan
		

15. Observation:

	@ComponentScan 
		-> Scans all the classes 
		-> which are annotated with the @Component annotation
		-> only within the package 
		-> where the @ComponentScan annotation is declared


	@ComponentScan(basePackages = {"package1", "package2"} )


	@ComponentScans({
			@ComponentScan (basePackages="com.deloitte"), 
			@ComponentScan (basePackages="com.differentpackage")
})


16. Dependency Injection

	Dependency Injection 
		-> tells that one class is dependent on other 

	Setter & Constructor Injection
		-> It is how the DI is achieved

	@Autowired
		-> Point of Dependency Injection
		-> What all Dep's have to be Injected



	******* Employee & Address Example: *****


	1. Setter DI [primitive types]
		
		-> with Address.java
		-> property names in XML are assigned to the Address instance variables through SETTER methods
		-> ERROR : If no setter method available for that particular property

	2. Setter DI [one bean into another bean]

		-> 	<bean>
				<property ref="<bean id to be injected>">
			</bean>
			
		

	3. CONSTRUCTOR DI

		->	 <bean>
				<constructor-arg value="Deepak"><>
				<constructor-arg ref="<bean id>"><>
			 </bean>		




	4. SETTER vs CONSTRUCTOR DI

		SETTER 		-> Optional dependencies
		CONSTRUCTOR 	-> Mandatory dependencies



	
	
	******* AUTOWIRE **********

	1. @Autowired -> on field/variable

	2. @Autowired -> on Setter Method

	3. @Autowired  -> on Constructor


	Autowire modes:

	1. byType :  If no autowire attribute used @Autowire is"byType"


	2. byName:	-> Bean & id -> one to one mapping
			-> no Duplicate Bean of same type must be there
			-> If so error

			-> If there is a duplicate bean of Address
			-> Matching Name then it is injected
			
			-> If no beanid is found with mentioned variable name then it will resort to "byType" provided there is only one Bean of the type

			-> Internally it is using SETTER Injection when there is a matching Bean id (a) available as compared to the variable name (a)
			
	Example: "Address" Bean  ->    OfficeAddress,   HomeAddress


	3. constructor 
		-> a constructor with that particular # of arguments
	

	4. In Java Configuration :
			@Bean(name="c", autowire= BY_NAME/BY_TYPE/NO)

 


17. Spring Bean LifeCycle:


	
	1. to use Annotations -> @PostConstruct, @Predestroy


		@PostConstruct
			 -> makes the method as an initialization method
			 -> which is called immediately after constructor 

		@PreDestroy
			 -> makes the method as an destroymethod
			 -> which is called just before the bean is destroyed

		-> Method names can be anything (custom-method names)


		Observation1
			 -> The annotations used are independent of method names

		Observation2
			 -> The annotations doesnt work if there is no entry of 				<context:annotation-config></context:annotation-config>
			    in spring-beans.xml


	2. XML -> init-method, destroy-method

		Example:

			<bean id="exynos" class="com.qualifier.Exynos" 
        			init-method="firstMethodAfterConstructor"
        			destroy-method="justBeforeDestroyMethod"/> 

		-> Method names can be anything (custom-method names)

	3. Implementing Interfaces

		For init:

			-> implement InitializingBean
			-> @Override  afterPropertiesSet()


		For destroy:

			-> implement DisposableBean
			-> @Override  destroy()



18. Spring Container Instantiation Observations:

		1. THis is where the Container is instantiated
		2. Given XML will be loaded
		3. It will scan all the bean declarations
		4. It will instantiate the beans
		5. While instantiation it will call the following in order
			a. constructor
			b. initialization method if any mentioned
		6. Takes care of Dependency Injection
		7. Provides API -> getBean()   for accessing the Beans instantiated 
		
		ClassPathXmlApplicationContext ctx 
			= new ClassPathXmlApplicationContext("spring-beans-qualifier.xml");


19. Lazy initialization:

	The beans instantiation will happen only when invoked
		-> call a method()
		-> getBean("<bean name>")
		-> Autowire 
			If @Lazy beans are Autowired they get instantiated at start itself
			If @Lazy beans are NOT Autowired they get instantiated when invoked explicitly
			


	XML way:

		-> Need to have an attribute on bean definition tag
			
				lazy-init="true"

	Annotation way :

		-> use @Lazy annotation ontop of the @Component/@Bean

	Observation:

		-> @Lazy doesnt work with xml configuration 
		-> must and should use   lazy-init="true"  attribute on bean def in xml
		

	Observation:
		
		-> Bean Instantiation/Creation will happen

			only for "SINGLETON" beans during context object creation



20. Scope

	Singleton : 

		-> By default the scope of a bean created is SINGLETON
		-> Only one object is created by container 
		-> even though we call repeatedly it gives same Object



	Prototype :
		
		-> This is NOT default scope
		-> Have to explicitly declare on a Bean definition
		-> Container creates a Bean (with scope prototype) only when requested
		-> getbean("<bean id>")
		-> Everytime you try to say getBean("<bean id>") it creates a new objects



ASPECT ORIENTED PROGRAMMING


1. Terminology

	-> Aspect	:   @Aspect : CLASS that bears the logic of cross cutting concern
	-> Pointcut	:   @Pointcut : We write pointcut expressions
	-> Advice	:   @Advice :(method annotation) Actual logic that has to be executed
	-> Joinpoint	:   @Joinpoint : App Point where the Advice has to be executed
	-> ...
	-> ...


2. Model	DTO	POJO

	-> variables, Getter Setters, toString, Constructors
	-> purpose: to Hold the Data
		Application:
			1. execute DB Query -> to hold the result (rows returned) 
				we need list of Models  List<EmployeeModel>

	-> EmployeeModel.java
	-> UserModel.java
	-> ProductMode.java

	-> Model : one of the components of MVC Design Pattern

	

3. Cross Cutting Concerns:

	-> Common logic to be executed across the Classes

	-> Exceptionhandling, 
	-> Logging
	-> Security
	-> Any common Business logic can also be an Aspect

4. Annotations

	-> @EnableAspectJAutoProxy(proxyTargetClass = true)


5.


	1. Instantiating the "Container" by creating the context object
	2. All the beans which we have declared they get created
	3. We are calling the method by getting the respective SpringBean
	4. em.getEmployeeById()


	:::: the flow is intercepted

	@Aspect(s)   ->   
	
		if the method which got called [getEmployeeById]
		is part of any of the pointcut expressions of the Aspects
		then the repspective Advice of the Aspect will be executed



6. Aspect Ordering:

	1. Only Aspect -> getEmployeeById() [No Confusion]

	2. There are 3 aspects -> getEmployeeById()
	
		Logging              -> getEmployeeById()
		ExceptionHandling    -> getEmployeeById()
		Security             -> getEmployeeById()

	3. Order the aspects

		(i) @Order(o/1/2/3/4)

		(ii) implements Order 
		     @Override
		     public int getOrder(){
			return 1/0;
		     }




7. Spring JDBC Template:

	<bean id="datasource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        	
        	<!-- SETTER Injection -->
        	<property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        	<property name="url" value="jdbc:mysql://localhost:3306/testemp"/>
        	<property name="username" value="root"/>
        	<property name="password" value="password"/>        		
        
        </bean>


        <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">      
        	<!-- Setter Dependency Injection -->  
        	<property name="dataSource" ref="datasource"/>        
        </bean>



        <bean id="edao" class="com.spring.jdbc.EmployeeDAO">
       		<!-- Setter Dependency Injection -->  
        	<property name="temp" ref="jdbcTemplate"/>
        </bean>  




8. Spring JDBC -> an alternative to Hibernate

9. Logging:

	- levels of Logging
		1. INFO
		2. DEBUG
		3. WARN
		4. ERROR
		5. FATAL

	- Logging to Files

	- live example of logging using the Tomcat

	- practical use case where the logging is used






Spring MVC:
----------

1. Overview
	MVC -> is a Design Pattern


	Addresses - > SEPARATION of Concerns



	Servlets:   Java + HTML
	JSP     :   HTML + Java



2. Divided the entire application into 3 main components



	Model -  Data Component [Holder]
		 Hold the data 
		 It provides a means to "Transfer" the data between the other components 
		 [Ui, DB, Java]
	

	View -  Data representation
		User Interface Component
		Web Tech : JSP, HTML, ......


	Controller - Starting point of Processing the Logic
	     Class: It receives input from View -> processes the data -> generates the resp
	     


UI    ->      		Controller -> Service -> DAO 			-> DB




3. Spring MVC Process Flow -


	1. Client [Browser]
		o/p: Http Request

	2. Front Controller ["DispatcherServlet"]
		i/p: URL [+ Request Data]

	3. Handler Mapping
		i/p: URL
		o/p: Mapping (Controller)

	4. Handler Adapter -> Controller -> Svc -> DAO -> DB
		i/p: Request
		o/p: Model + View (logical name)  packed in :  MODELANDVIEW object

	5. View Resolver
		i/p: View (logical name)
		o/p: Full view name ( prefix + viewname + suffix )

	6. View :
		DS 	-> Prepares full view 
			-> using 
				Model from Controller/Handler Adapter		
				Full view name from View Resolver


	7. Response:
			Submitted back to Client

	

4. Config File Declarations

	2 ways of declaring our .xml files where we declare all our beans/classes


	1. Scenario:  Define the config  .xml file as

			test-servlet.xml   ===   [servlet-name]-servlet.xml

	   IMPORT all other files in above xml

			<import resource="spring-core-context.xml"/>
   			<import resource="spring-DAO.xml"/>
    			<import resource="spring-services.xml"/>
		
	
		web.xml
			-> <servlet-name>spring<servlet-name>     =>   spring-servlet.xml


	Observation: 
		(a) Dispatcher Servlet auto-detects the above files [based on "-servlet"]
		(b) Not mandatory to declare them as <context-param> values in web.xml


		** The [servlet-name]-servlet.xml is the default name of config file
		** WebContent/WEB-INF is the default location for application context file.



	2. Scenario :  Define all the .xml files as -> custom names

			test.xml
			demo.xml
			sample.xml

	Observation:		

		For "CUSTOM" Config files (.XMLs)
			- To use Custom name or location 
			- Need to inform spring framework 
			- by adding ContextLoaderListener in web.xml file.


		(a) Dispatcher Servlet CANNOT auto-detect the above [custom xml] files 
		(b) MANDATORY to declare them as <context-param> values in web.xml
		(c) Also need to declare <listener-class> : ContextLoaderListener




		<web-app...>
		<!-------- DispatcherServlet definition ----->
		....
			<context-param>
				<param-name>contextConfigLocation</param-name>
				<param-value>/WEB-INF/HelloWorld-servlet.xml, 
				             /WEB-INF/test.xml,
					     /WEB-INF/test.xml 
				</param-value>
			</context-param>
	
			<listener>
				<listener-class>
					org.springframework.web.context.ContextLoaderListener
				</listener-class>
			</listener>
		</web-app>





	Observation:

		Spring framework 
			->loads "application context" from [servlet-name]-servlet.xml file.




-> Strategies:  ViewResolver
-> Strategies:  HandlerMapping
-> Strategies:  HandlerAdapter
-> Strategies:  Theme
-> Strategies:  HttpMessageConverter



5. HANDLER MAPPING - STRATEGIES


	Overview:

	0. HandlerMapping -> Interface
		
	   Used For:

		1. It is used to find the Component/Controller mapped to the respective URL


	1a. BeanNameUrlHandlerMapping : - STRATEGY

		a. It is the default implementation used by the Dispatcher Servlet
		b. It maps a URL(an incoming http request) to bean with that particular name
		c. URL : '/app'     BeanName:   app
		
		Example:
		========
		
		URL :  http://localhost:8080/demo/hello

		@Configuration
		class Abc{
			@Bean("hello"){
			public HelloWorld hellowWorld{
				return new HelloWorld();
			}
		}

	1b. We can use different patterns (ant-style pattern) for this mapping
		'/app/**'
	   It will match all the paths below 'app'




	2. RequestMappingHandlerMapping - STRATEGY

		@RequestMapping("/hello")
		class HelloWorld{
		}


	   1. This actually was introduced from - SPRING 3.1

	   2. @RequestParam, @PathVariable ............





6. @RequestMapping:

	Annotation is used @ both 
 
		-> Class Level
		-> Method Level

	Use: 

		-> Used to find the RequestHandler Method
		-> Incoming URL pattern must match the Annotation ("/<path>") provided



	Scenario 1: @RequestMapping annotation applied to both class and methods.


		@RestController
		@RequestMapping("/home")
		public class IndexController {
		    @RequestMapping("/")
		    String get() {
		        //mapped to hostname:port/home/
		        return "Hello from get";
		    }
		    @RequestMapping("/index")
		    String index() {
		        //mapped to hostname:port/home/index/
		        return "Hello from index";
		    }
		}



	Scenario 2: @RequestMapping With Multiple URIs

		@RestController
		@RequestMapping("/home")
		public class IndexController {
		
			@RequestMapping(value = {
		        	"",
			        "/page",	
			        "page*",
			        "view/*,**/msg"
			})
			String indexMultipleMapping() {
			        return "Hello from index multiple mapping.";
			}
		}

		// localhost:8080/spring.mvc/home/page


		Note: @RequestMapping supports wildcards and ant-style paths.


		localhost:8080/home
		localhost:8080/home/
		localhost:8080/home/page
		localhost:8080/home/pageabc
		localhost:8080/home/view/
		localhost:8080/home/view/view
		localhost:8080/home/xyz/abc/view




	Scenario 3:  @RequestMapping With @RequestParam


	@RequestParam - used to bind web request param to param of the handler method.
		

		@RestController
		@RequestMapping("/home")
		public class IndexController {

		    //  param id will be mapped to the personId parameter
		    @RequestMapping(value = "/id")
		    String getIdByValue(@RequestParam("id") String personId) {
		        System.out.println("ID is " + personId);
		        return "Get ID from query string of URL with value element";
		    }

		    // value can be omitted if the req param & handler method param are same
		    @RequestMapping(value = "/personId")
		    String getId(@RequestParam String personId) {
		        System.out.println("ID is " + personId);
		        return "Get ID from query string of URL without value element";
		    }
		}

		
		Supported URLS:

			/home/name?person=xyz
			/home/name





	Scenario 4:  @RequestMapping With Producible and Consumable


		@RestController
		@RequestMapping("/home")
		public class IndexController {

			

		    // URL: http:localhost:8080/spring.mvc/home/prod	

		    @RequestMapping(value = "/prod", produces = {"application/JSON"})
		    @ResponseBody
		    String getProduces() {
		        return "Produces attribute";
		    }
		
		    @RequestMapping(value = "/cons", consumes = {"application/JSON","application/XML"})
		    @ResponseBody
		    String getConsumes() {
		        return "Consumes attribute"; 
		    }
		}



		Observation:

			-> If you return "String"  after executing Req. Handler method
				
					By default Dispatcher Servlet treats the String as "Logical View Name"

			-> Use @ResponseBody to treat the return type as an Object




		Observations:

		To produce the object in the requested media type 
			-> Use: produces element in combination with @ResponseBody 

		To consume the object with the requested media 
			-> Use: consumes element in combination with the @RequestBody 




		// Observations - Postman:

			1. GET method doesnt have body
			2. Can transfer data using Params Section(Postman)
	
			3. Response Body - section

				a. content-type [produces]

			4. REQUEST - Header
				b. content-type [consumes]

			5. Seen different Content-types

			6. How to execute a REQUEST using Postman

			7. REST API - Client

			8. Creating and maintaining Collections

			9. Workspaces

			10. Response -> Body, status code, response generation time, 

			11. Import feature -> Importing the API's/ Endpoints from one system to another

			12. SWAGGER -> API Management TOOL / Client







	Scenario 5:  @RequestMapping With Headers

		@RestController
		@RequestMapping("/home")
		public class IndexController {
		    @RequestMapping(value = "/head", headers = {
		        "content-type=text/plain"
		    })
		    String post() {
		        return "Mapping applied along with headers";
		    }
		}


	

	Scenario 6:  @RequestMapping With Request Parameters
	
		@RestController
		@RequestMapping("/home")
		public class IndexController {
		    @RequestMapping(value = "/fetch", params = {"personId=10"})
		    String getParams(@RequestParam("personId") String id) {
		        return "Fetched parameter using params attribute = " + id;
		    }
		    @RequestMapping(value = "/fetch", params = {"personId=20"})
		    String getParamsDifferent(@RequestParam("personId") String id) {
		        return "Fetched parameter using params attribute = " + id;
		    }
		}


		Observations:
			
			a. The value of the incoming URL parameter -> must match in the params{} attribute of the @Request Mapping
			b. If not matched -> then "400 BAD REQUEST" will be the RESPONSE CODE

			c. Used to filter requests based on certain values declared in param{}
			d. Usecase : Authorization

			e. param name in the incoming request MUST MATCH the param declared in the params{} attribute of @RequestMapping
			f. No spaces between the paramname, = and value
	


		
	Scenario 7: Using @RequestMapping With Dynamic URIs



		@RestController
		@RequestMapping("/home")
		public class IndexController {
		    @RequestMapping(value = "/fetch/{id}", method = RequestMethod.GET)
		    String getDynamicUriValue(@PathVariable String id) {
		        System.out.println("ID is " + id);
		        return "Dynamic URI parameter fetched";
		    }
		    @RequestMapping(value = "/fetch/{id:[a-z]+}/{name}", 
					method = RequestMethod.GET)
		    String getDynamicUriValueRegex(@PathVariable("name") String name) {
		        System.out.println("Name is " + name);
		        return "Dynamic URI parameter fetched using regex";
		    }
		}



		Observation:

			-> @RequestMapping annotation is used 
			-> in combination with the @PathVaraible annotation 
			-> to handle dynamic URIs





	Scenario 8:  @RequestMapping Default Handler Method

		@RestController
		@RequestMapping("/home")
		public class IndexController {
		    @RequestMapping()
		    String
		    default () {
		        return "This is a default method for the class";
		    }
		}

		Observation:
			 -> request to /home will be handled by the default() method 
			 -> as the annotation does not specify any value.








7. @RequestBody


	->  maps the HttpRequest body to a transfer or domain object, 
	->  enabling automatic deserialization of inbound HttpRequest body onto a Java object


	Example:

		@PostMapping("/request")
		public ResponseEntity postController(@RequestBody LoginForm loginForm) {
		 
		    exampleService.fakeAuthenticate(loginForm);
		    	

		}




	Observation:

		-> Spring automatically deserializes the JSON into a Java type
		-> assuming an appropriate one is specified



	-----------------------

	-> the type we annotate with the @RequestBody annotation 

		public class LoginForm {
		    private String username;
		    private String password;
		    // ...
		}

	-> must correspond to the JSON sent from our client-side controller:



	ACCEPT: [Client-SIDE]

		-> Accept header is used by HTTP clients to tell the server which type of content they expect/prefer as response. 
	
	CONTENT-TYPE: [MUTUAL Client & Server]

		-> Content-type can be used both by clients and servers to identify format of data in their request (client) or response (server) 		-> therefore, help the other part interpret correctly the information.



	By default -> CONTENT-TYPE : TEXT


	For @RequestBody

		Observation: 

			-> For sure define the 
				(i) Media Type @ Server side
				(ii) Content Type on the @ Client Side


		Common Exception:   415 - Unsupported Media Type

		(a)  Added Jacksondatabind Maven Dependency
			(i)  It is a MessageConverter
			(ii) Converts JSON Data to JAVA Object and viceversa
		
		(b) Postman/Client side
			(i) Choose -> Content-Type :  application/json
			(ii) Serverside ->  @RequestMapping(consumes= MEDIATYPE.APPLICATION_JSON_VALUE)
		




8. @ResponseBody

	-> tells a controller that 
	-> the object returned is automatically serialized into JSON 
	-> and passed back into the HttpResponse object.


	Custom Response Object:


		public class ResponseTransfer {
   			 private String text; 
    
    			// standard getters/setters
		}



	Associated Controller:

		@Controller
		@RequestMapping("/post")
		public class ExamplePostController {
		
		    @Autowired
		    ExampleService exampleService;
		
		    @PostMapping("/response")
		    @ResponseBody
		    public ResponseTransfer postResponseController(
		      @RequestBody LoginForm loginForm) {
		        return new ResponseTransfer("Thanks For Posting!!!");
		     }
		}
	


10.@RestController

	-> @Controller + @Response Body
	-> It eliminates usage of @ResponseBody on each and every ()





11. SPRING MVC - CRUD Operations

	-> CREATE/READ/UPDATE/DELETE

	-> Employee related info
	

	->  Step 1: URL called from browser ->  /empform

	->  Step 2: 		
		a.EmployeeController : showform() is invoked
		b.Employee Object is created
		c.Object is sent to the next VIEW (empform.jsp)

	->  Step 3: SPRING FORM 
		a. modelAttribute -> catches Object created in Step 2
		b. Sets  all the values of Object to respective fields 			
		c. Using path attribute (binding parameter)
		d. Click "Add Employee"

	    Observation:
		(i) Default modelAttribute = "command"
		(ii) taglib -> springframework.org/tags/form
		(iii) path -> binding parameter
		

	-> Step 4: 
		a. 

	



12. @ModelAttribute

	Binds a method parameter or method return value to a named model attribute and then exposes it to a web view


	Usage:
		(i) 	on Method Parameter/Argument
		(ii) 	on Method


	(i) As a Method Argument

		-> it binds the form data with a bean
		-> controller annotated with @RequestMapping can have custom class argument(s) annotated with @ModelAttribute
		-> This is what is commonly known as data binding in Spring-MVC ::: saves effort to parse each form field individually.\

		-> argument should be retrieved from the model
		-> arguments fields should be populated from all request parameters that have matching names.	
	

	(ii) At Method Level
		
		-> indicates the purpose of that method is to add one or more model attributes
		-> Adds attribute to all models defined in the controller class
		-> Methods are invoked before the controller methods annotated with @RequestMapping are invoked.

		
	Uses:

		Eliminates lots of manual code
			

	Exercise:


		a. Create a Form (empform)
		b. Create a Controller
		c. Create resultant view (viewform)
		d. modelAttribute -> on Form
		e. @ModelAttribute -> on Method Argument
		f. 




13. Bean Validation API

	Need to include a 3rd party library/ dependency - HIBERNATE VALIDATOR
	It has implemented some Specifications -> JSR-303 / JSR-349
	         a. Hibernate Validator 
		 b. Apache bean Validator
	
	JSR: Java Specification Request
		  : Set of standards provided by a Community called JCP
	
	JCP : Java Comunity Process
	     : Given out 2 standards which are related to bean Validation
	
	Spring MVC Says that : 
	      It supports any library that implements one of the these 2 specifications
	Hibernate Validator is the most POPULAR Library



	Changes: 

		1. Added hibernate-validator dependency
		2. Used the annotation -> @NotNull, @Size
		3. 


2. Example ->

	Observation:

		1. Instead of ModelAndView we can use them independently as

			a. Model m [Object]  is prepared by DS -> populates the Model Object
				




Spring Boot Applications
========================

1. AutoConfiguration

2. Annotation Driven

3. Starter-projects/dependencies

4. starter-parent

5. Embedded Tomcat Server

6. maintains all the versions of the dependencies implicitly as per SB version

	-> 1.4 :    maintains lots of dependencies and associated versions internally
	
	-> 2.0 :    maintains lots of dependencies and associated versions internally



1. Create SB Projects

	-> Using Spring Initializr [http://start.spring.io]


	-> Using options in STS



2. S B Actuator

	-> SB Dependency
	
	->  Gives information about the project

	-> what :  health, metrics, mappings, info, etc.. etc...

	-> how  :  through ENDPOINTS

	-> Endpoint? -> URL : 

		1. http://localhost:8080/spring.mvc/showForm
		2. http://localhost:8080/spring.mvc/getEmployeeById/




SB Project are mainly used for :

	-> REST API development


	-> Representation State Transfer

		HTTP : Hypertext transfer Protocol


	-> Http Call based

	-> based on HTTP methods -> GET, POST, PUT, DELETE - PATCH OPTIONS HEAD TRACE ...



Autoconfiguration:

	-> All the classes which are on the class path of the SB application

	-> They are instantiated

	-> Some of the classes they for sure need some properties 
		We have to supply those properties to get the beans created

	-> SB application

		(1) Embedded SErver -> Tomcat
		(2) Embedded Database -> DB

			by default it asks for : H2, HSQL, Derby URL's 
	
			DataSourceAutoConfiguration
				
				


->  @RestController = @Controller + @ResponseBody





-> @SpringBootApplication

	-> on top of the Class having "main()" method
	-> DemoApplication.java

	-> Everytime you create a SB APplication
	-> You will get a class with main()
	-> <ProjectName>Application.java

	-> Combo of 3 Annotation

		(a) @Configuration

			-> Creating the beans specified in the Configuration Java File


		(b) @AutoConfiguration :

			-> beans are automatically created based on the available the classpath dependencies 

			-> DataSourceAutoConfiguration [url, pwd, .......]

		(c) @ComponentScan      : All the classes annotatted with @ Components in that particular package are identified





-> profiles:

	application.properties (resolved at the last)
		default-profile = dev

	application-dev.properties
	application-qa.properties
	application-prod.properties




-> Embedded Tomcat : 

	 Tomcat initialized with port(s): 8080 (http)
	 Starting service [Tomcat]
	 Starting Servlet engine: [Apache Tomcat/9.0.52]


-> Embedded DB : H2

	HikariPool-1 - Starting...
	HikariPool-1 - Start completed.

	Logging in into the H2 DB  -> 

	Path -> /h2   or  /h2-console


-> Default Actuator Endpoint exposed upon the application start-up

	http://127.0.0.1:8080/actuator   -> /actuator
					 -> /actuator/health
					 -> /actuator/health/{*path}



	application.properties ->    management.endpoints.web.exposure.include=*


-> Logging Level:


	application.properties ->   logging.level.web = DEBUG   [getting the DEBUG statements in Console apart from INFO & WARN]


-> actuator/beans

	It actually lists all the beans that are going to get created by the Container
	
	Alos in details will list the associated Bean Dependencies

-> actuator/health

	indicates whether the application is up and running or not





keytool -importcert -alias your-alias -keystore “C:\Program Files\Java\jre1.8.0_91\lib\security\cacerts” -storepass changeit -file C:\Users\dhanumansetty\Desktop\sts.cer








