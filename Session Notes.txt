SPRING BASICS - I



Famework - everything is predefined as modules

1. Security - Spring supports Security
2. JDBC - Spring JDBC supports the DB connectivity
3. Monitoring - We do have Actuator
4. AOP - Aspect Oriented Programming [ to address Cross Cutting Concerns]
5. MVC - Spring MVC module supports the Model View Controller Design pattern

Standalone Spring Programs : Spring Core



Spring Modules
Spring FW 


Loose Coupling is achieved -> See this step by step



Spring core concepts:

1. IoC Container - Inversion of Control

	- In Java creation of objects is done by Developer
	- We are delegating the responsibility of Object creation to Spring Container
	- config file : springbeans.xml
	- In the config file we declare all the beans
	- Every object created by spring is called -> Spring "BEAN"



2. Wrong Impression:

	- Spring IoC will created the beans declared in the the config (.xml) file
	- But still you can create the objects in normal way
	- "new A();"

3. Dependency Injection
	- The concept of injecting dependencies into respective beans/classes using Spring concepts	

	-Types of DI's

	- Constructor: DEPENDENCY INJECTION
	- Setter : DEPENDENCY INJECTION

4. How to configure a Spring Application:

	(a) XML Configuration (beans.xml)
	(b) Java Based Configuration 
		-> entire XML is replaced by a JAVA File
	(c) Annotations

5. Annotations:
	
	-(a) @Component	- Class level Annotation
	(b) @Controller - Class level Annotation
	(c) @Service	- Class level Annotation
	(d) @Repository	- Class level Annotation
	-(e) @Bean
	-(f) @ComponentScan
	-(g) @Autowired  - Tells the Container how to inject the dependencies
	-(h) @Configuration
	(i) @Qualifier


Steoreotype Annotations
	->  (a), (b), (c), (d), (h), @ControllerAdvice, @RestController



Client (Browser)  ->   Controller(Servlet) -> Service -> DAO    -> DB

Servlet/Controllers : receives the incoming request
Service : You perform the business logic



6. Bean Scopes
	- 1. Singleton
	- 2. Prototype
	- 3. request
	- 4. session
	- 5. Global Session(Deprecated - from Spring 5.x)
	- 5. Application


7. Bean Lifecycle 
	- init()
	- destroy()

	- 3 different ways to achieve overriding the lifecycle methods
		a. use xml attributes 
		b. annotations [@PostConstruct  ,  @PreDestroy]
		c. can implement 2 interfaces
			(i) InitializingBean
			(ii) DisposableBean

8. Autowiring
	- Process of connecting 2 Beans
	- Achieving Dependency Injection

	- XML         [autowire="byName"    autowire="byType"]
          Annotation  [Autowiring modes]

	- Autowiring modes -> byName, byType, no


9. Qualifier -> 
		



10. ClassPathXmlApplicationContext:

	i/p to the class 
		-> "spring-beans.xml"   [XML file]

	ctx (object)
		 -> provides API 
			-> to extract beans generated by container


	id in <bean id="<id of the bean>"> delcaration 
		-> must match the getBean("<id of the bean>") 

	Typecast the bean provided by the container (getbean())

	ctx.close()


11.AnnotationConfigApplicationContext:
	
	i/p to the class
		-> "SpringJavaConfig.class"   
		-> [class annotated with @ Configuration]

	ctx (object)
		 -> provides API 
			-> to extract beans generated by container

	methodname of method annotated with @Bean (in @Configuration file)
		-> must match the getBean("<method name>")


	Typecast the bean provided by the container (getbean())



	ctx.close()


12.  	@Bean(name="c") -> alias name of the object being returned
	@Bean(name="b") -> alias name of the object being returned


13. spring-beans.xml  =====   @Configuration (SprinJavaConfig.class)
    <bean> 	      =====   @Bean
    <bean id="">      =====   name of the method



14. @ComponentScan

	Def: Instead of explicitly specifying the Bean declarations 
			-> either in xml
			-> or in Configuration file

	     Use "ComponentScan"


	- In XML
		<context:component-scan basePackage="com.deloitte">
				</context: component-scan>


	- In Configuration Class
		@ComponentScan
		

15. Observation:

	@ComponentScan 
		-> Scans all the classes 
		-> which are annotated with the @Component annotation
		-> only within the package 
		-> where the @ComponentScan annotation is declared


	@ComponentScan(basePackages = {"package1", "package2"} )


	@ComponentScans({
			@ComponentScan (basePackages="com.deloitte"), 
			@ComponentScan (basePackages="com.differentpackage")
})


16. Dependency Injection

	Dependency Injection 
		-> tells that one class is dependent on other 

	Setter & Constructor Injection
		-> It is how the DI is achieved

	@Autowired
		-> Point of Dependency Injection
		-> What all Dep's have to be Injected



	******* Employee & Address Example: *****


	1. Setter DI [primitive types]
		
		-> with Address.java
		-> property names in XML are assigned to the Address instance variables through SETTER methods
		-> ERROR : If no setter method available for that particular property

	2. Setter DI [one bean into another bean]

		-> 	<bean>
				<property ref="<bean id to be injected>">
			</bean>
			
		

	3. CONSTRUCTOR DI

		->	 <bean>
				<constructor-arg value="Deepak"><>
				<constructor-arg ref="<bean id>"><>
			 </bean>		




	4. SETTER vs CONSTRUCTOR DI

		SETTER 		-> Optional dependencies
		CONSTRUCTOR 	-> Mandatory dependencies



	
	
	******* AUTOWIRE **********

	1. @Autowired -> on field/variable

	2. @Autowired -> on Setter Method

	3. @Autowired  -> on Constructor


	Autowire modes:

	1. byType :  If no autowire attribute used @Autowire is"byType"


	2. byName:	-> Bean & id -> one to one mapping
			-> no Duplicate Bean of same type must be there
			-> If so error

			-> If there is a duplicate bean of Address
			-> Matching Name then it is injected
			
			-> If no beanid is found with mentioned variable name then it will resort to "byType" provided there is only one Bean of the type

			-> Internally it is using SETTER Injection when there is a matching Bean id (a) available as compared to the variable name (a)
			
	Example: "Address" Bean  ->    OfficeAddress,   HomeAddress


	3. constructor 
		-> a constructor with that particular # of arguments
	

	4. In Java Configuration :
			@Bean(name="c", autowire= BY_NAME/BY_TYPE/NO)

 


17. Spring Bean LifeCycle:


	
	1. to use Annotations -> @PostConstruct, @Predestroy


		@PostConstruct
			 -> makes the method as an initialization method
			 -> which is called immediately after constructor 

		@PreDestroy
			 -> makes the method as an destroymethod
			 -> which is called just before the bean is destroyed

		-> Method names can be anything (custom-method names)


		Observation1
			 -> The annotations used are independent of method names

		Observation2
			 -> The annotations doesnt work if there is no entry of 				<context:annotation-config></context:annotation-config>
			    in spring-beans.xml


	2. XML -> init-method, destroy-method

		Example:

			<bean id="exynos" class="com.qualifier.Exynos" 
        			init-method="firstMethodAfterConstructor"
        			destroy-method="justBeforeDestroyMethod"/> 

		-> Method names can be anything (custom-method names)

	3. Implementing Interfaces

		For init:

			-> implement InitializingBean
			-> @Override  afterPropertiesSet()


		For destroy:

			-> implement DisposableBean
			-> @Override  destroy()



18. Spring Container Instantiation Observations:

		1. THis is where the Container is instantiated
		2. Given XML will be loaded
		3. It will scan all the bean declarations
		4. It will instantiate the beans
		5. While instantiation it will call the following in order
			a. constructor
			b. initialization method if any mentioned
		6. Takes care of Dependency Injection
		7. Provides API -> getBean()   for accessing the Beans instantiated 
		
		ClassPathXmlApplicationContext ctx 
			= new ClassPathXmlApplicationContext("spring-beans-qualifier.xml");


19. Lazy initialization:

	The beans instantiation will happen only when invoked
		-> call a method()
		-> getBean("<bean name>")
		-> Autowire 
			If @Lazy beans are Autowired they get instantiated at start itself
			If @Lazy beans are NOT Autowired they get instantiated when invoked explicitly
			


	XML way:

		-> Need to have an attribute on bean definition tag
			
				lazy-init="true"

	Annotation way :

		-> use @Lazy annotation ontop of the @Component/@Bean

	Observation:

		-> @Lazy doesnt work with xml configuration 
		-> must and should use   lazy-init="true"  attribute on bean def in xml
		

	Observation:
		
		-> Bean Instantiation/Creation will happen

			only for "SINGLETON" beans during context object creation



20. Scope

	Singleton : 

		-> By default the scope of a bean created is SINGLETON
		-> Only one object is created by container 
		-> even though we call repeatedly it gives same Object



	Prototype :
		
		-> This is NOT default scope
		-> Have to explicitly declare on a Bean definition
		-> Container creates a Bean (with scope prototype) only when requested
		-> getbean("<bean id>")
		-> Everytime you try to say getBean("<bean id>") it creates a new objects



ASPECT ORIENTED PROGRAMMING


1. Terminology

	-> Aspect	:   @Aspect : CLASS that bears the logic of cross cutting concern
	-> Pointcut	:   @Pointcut : We write pointcut expressions
	-> Advice	:   @Advice :(method annotation) Actual logic that has to be executed
	-> Joinpoint	:   @Joinpoint : App Point where the Advice has to be executed
	-> ...
	-> ...


2. Model	DTO	POJO

	-> variables, Getter Setters, toString, Constructors
	-> purpose: to Hold the Data
		Application:
			1. execute DB Query -> to hold the result (rows returned) 
				we need list of Models  List<EmployeeModel>

	-> EmployeeModel.java
	-> UserModel.java
	-> ProductMode.java

	-> Model : one of the components of MVC Design Pattern

	

3. Cross Cutting Concerns:

	-> Common logic to be executed across the Classes

	-> Exceptionhandling, 
	-> Logging
	-> Security
	-> Any common Business logic can also be an Aspect

4. Annotations

	-> @EnableAspectJAutoProxy(proxyTargetClass = true)


5.


	1. Instantiating the "Container" by creating the context object
	2. All the beans which we have declared they get created
	3. We are calling the method by getting the respective SpringBean
	4. em.getEmployeeById()


	:::: the flow is intercepted

	@Aspect(s)   ->   
	
		if the method which got called [getEmployeeById]
		is part of any of the pointcut expressions of the Aspects
		then the repspective Advice of the Aspect will be executed



6. Aspect Ordering:

	1. Only Aspect -> getEmployeeById() [No Confusion]

	2. There are 3 aspects -> getEmployeeById()
	
		Logging              -> getEmployeeById()
		ExceptionHandling    -> getEmployeeById()
		Security             -> getEmployeeById()

	3. Order the aspects

		(i) @Order(o/1/2/3/4)

		(ii) implements Order 
		     @Override
		     public int getOrder(){
			return 1/0;
		     }




7. Spring JDBC Template:

	<bean id="datasource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        	
        	<!-- SETTER Injection -->
        	<property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        	<property name="url" value="jdbc:mysql://localhost:3306/testemp"/>
        	<property name="username" value="root"/>
        	<property name="password" value="password"/>        		
        
        </bean>


        <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">      
        	<!-- Setter Dependency Injection -->  
        	<property name="dataSource" ref="datasource"/>        
        </bean>



        <bean id="edao" class="com.spring.jdbc.EmployeeDAO">
       		<!-- Setter Dependency Injection -->  
        	<property name="temp" ref="jdbcTemplate"/>
        </bean>  




8. Spring JDBC -> an alternative to Hibernate

9. Logging:

	- levels of Logging
		1. INFO
		2. DEBUG
		3. WARN
		4. ERROR
		5. FATAL

	- Logging to Files

	- live example of logging using the Tomcat

	- practical use case where the logging is used


































